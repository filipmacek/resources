[{"slug":"dynamic-width-in-d3-charts","title":"Dynamic width in D3 charts","createdAt":"2022-11-20T22:32:55.965Z","description":"How to set chart width dynamically depending on the DOM context and resizing","content":"Test\n","author":"Filip","rootPath":"../articles/react/series/charts","rawUrl":"https://raw.githubusercontent.com/filipmacek/resources/articles/react/series/charts/dynamic-width.mdx","serie":"Charts"},{"slug":"generate-const-in-a-struct-with-rust-macros","title":"Generate const in a struct with Rust macros","tags":["RUST"],"createdAt":"2022-10-13T13:56:00.819Z","description":"Leverage macros to generate constant values for struct type","content":"\nMacros are a really powerful tool in your Rust toolkit, and you get many benefits if you know how to use them properly.\nFor example, you can generate multiple constant values in struct with macro.\nThe good thing about struct constants is they are easy to create and they come with all the related struct methods and implemented traits.\\\nI got an idea for this article when I was looking at code of `http` Rust library [here](https://github.com/hyperium/http/blob/master/src/status.rs).\n\n## Intro\n\nLet's model HTTP status code in Rust. We know that each status code has a corresponding integer number and string title.\nIt's easier to remember it by title because it will tell us more than just a raw number. Creating them with constants is easy and intuitive:\n\n```rust\nlet ok = StatusCode::OK\nlet accepted = StatusCode:: ACCEPTED\nlet server_error = StatusCode::INTERNAL_SERVER_ERROR\n```\n\n## Solution\n\nWe can model HTTP status code with a tuple struct type that only contains one integer value, `u16` as code number.\nWe then create some standard methods and constructor `new`.\\\nTo create constant value just write `pub const` inside `impl` block for struct and put string for each status code inside `title` method.\n\n```rust\npub struct StatusCode(u16);\n\nimpl StatusCode{\n    pub const OK:StatusCode = StatusCode(200);\n    pub const CREATED:StatusCode = StatusCode(201);\n    pub const INTERNAL_SERVER_ERROR:StatusCode = StatusCode(500);\n    /// ...others\n\n    pub fn new(num:u16)->Self{ Self(num) }\n\n    pub fn number(&self)->u16{ self.0 }\n\n    pub fn title(&self)->Option<&'static str>{\n        match self.0 {\n            200 => Some(\"OK\"),\n            201 => Some(\"Created\"),\n            500 => Some(\"Internal Server Error\"),\n            _ => None\n        }\n    }\n}\n```\n\nAnd if you need to print status code, you must implement `Display` trait which will use `self.title` method.\n\n```rust\nimpl Display for StatusCode{\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f,\"{} {}\",self.0,self.title().unwrap_or(\"<unknown status code>\"))\n    }\n}\n```\n\nThis is the normal way of creating const variables inside structs. But there are few concerns that I have about this way compared to macro method\nwhich we will show bellow.\n\n- there are over 63 status code so impl block will be long and filled with const values\n- writing repeating syntax for every new constant\n- implementations and methods are closely coupled with creation of instances for struct type\n\nBetter and more clear approach would be to move instance creation outside this `impl` block and\nleave only methods for clear and concise view what functionality this type has.\n\n```rust\npub struct StatusCode(u16);\n\nimpl StatusCode{\n    pub fn new(num:u16)->Self { Self(num) }\n\n    pub fn number(&self)->u16 { self.0 }\n\n    pub fn title(&self)->Option<&'static str> {\n        all_titles(self.0)\n    }\n}\n```\n\n## Macros to rescue\n\nWhat are macros in general? It a way of writing code that writes other code, which is known as _metaprogramming_.\nIdea behind macro is basically to produce more code with less code, if that makes sense :D .\nThere are a lot of similarities between macros and functions. However, macros have some additional powers that functions don't and there are some differences.\n\n- in function signature you must type all the input params, but macros can take variable number of params\n- you can define and call functions anywhere, but macros need to be defined or brought into scope before you call them\n- macros definition are generally more difficult to read, understand, and maintain\n- macros are expanded before the compiler interprets the meaning of the code\n\nWe create macros with `marcro_rules!` keyword. Then we use a set of parentheses to encompass the whole pattern.\nDollar sign `$` is used as macro variable identifier to be distinguished from a regular Rust variable.\\\nPatterns `$(...)*` and `$(...)+` specifies that the pattern `...` matches zero/one or more times.\n\nWe will use macro for two things. One is to generate const value and other is for creating `all_titles` function where\nwe typed all the status codes and its corresponding string title.\n\n\nWhen writing macros, it's always a good idea to first visualize how would you call this macro, and then you start implementing it.\nIt will help you understand what you actually want from macro.\n\n```rust\nstatus_codes! {\n    (200,OK,\"OK\");\n    (201, CREATED, \"Created\");\n    (500, INTERNAL_SERVER_ERROR, \"Internal Server Error\");\n}\n```\n\nThe next thing is to figure out how to type expression `(200,OK,'OK');` inside macro.\nMacro variables are represented like  `$NAME:TYPE` where `NAME` is the name of variable that we will use in macro block,\nand `TYPE` is fragment specifier which matches Rust syntax to this variable. We will need `expr` and `ident` specifiers. The results is:\n\n```\n  ($number: expr,$konst: ident,$phrase: expr);\n```\n\nWe then surround it with `$(...)+` to indicate that our macro will accept multiple value that matches our predefined pattern.\nNext is to define `impl` block for our `StatusCode` struct where we will put all the status codes as struct constant value.\n\n```rust\nimpl StatusCode{\n    $( pub const $konst:StatusCode = StatusCode($number); )+\n}\n```\n\nAs you see pattern `$(...)+` is also used for code multiplication.\nAnd at the end we define our function `all_titles` where all `phrases` are typed.\n\n\n```rust\nfn all_titles(code:u16)->Option<&'static str>{\n    match code {\n        $ ( $number => Some($phrase), )+\n        _ => None\n    }\n}\n```\n\nAnd that's it. Full macro code is now:\n\n```rust\nmacro_rules! status_codes{\n    (\n        $(\n            ($number:expr,$konst:ident,$phrase:expr);\n        )+\n    )=>{\n        impl StatusCode{\n            $( pub const $konst:StatusCode = StatusCode($number); )+\n        }\n\n        fn all_titles(code:u16)->Option<&'static str>{\n            match code {\n                $ ( $number => Some($phrase), )+\n                _ => None\n            }\n        }\n\n    }\n}\n```\n\nWith this macro you just type status code,titles and variable names ,and all constant values are automatically generated.\n","author":"Filip","rootPath":"../articles/rust/series/rust-patterns","rawUrl":"https://raw.githubusercontent.com/filipmacek/resources/articles/rust/series/rust-patterns/generating_const_in_struct.mdx","serie":"Rust patterns"}]